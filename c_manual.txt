/*Alina*/

pthread_mutex_t region_mutex = PTHREAD_MUTEX_INITIALIZER;
Тип переменной pthread_t является средством ссылки на потоки. устанавливаются атрибуты по умолчанию

pthread_cond_t space_available = PTHREAD_COND_INITIALIZER;
Условная переменная всегда используется совместно с мьютексом. П

void *producer(); //При создании потока с использованием pthreads вам нужно указать его на  функцию,чтобы он начал выполнение. Функция должна возвращать void * и принимать один аргумент void * .
 

    pthread_create(&consumer_thread, NULL, consumer, NULL); //Этот метод - создание потока -  принимает четыре аргумента: указатель на переменную pthread_t , любые дополнительные атрибуты (не беспокойтесь об этом на данный момент - просто установите его в NULL), указатель на вызываемую функцию (то есть: имя точки входа) и указатель передается как аргумент функции.

   
    pthread_join(consumer_thread,NULL); //Когда только что созданный поток завершил выполнение бит, нам нужно объединить все. Это выполняется с помощью функции pthread_join которая принимает два параметра: переменную pthread_t используемую при вызове pthread_create (а не указатель на этот раз), и указатель на указатель возвращаемого значения (не беспокойтесь об этом сейчас - просто установите его в NULL ).


        pthread_mutex_lock(&region_mutex);//блокирует остальные потоки, Успешный вызов блокировки мьютекса посредством mutex_lock () вызовет другой поток, который также пытается заблокировать один и тот же мьютекс, чтобы блокировать до тех пор, пока поток владельца не разблокирует его с помощью mutex_unlock () . Темы в рамках одного процесса или внутри других процессов могут совместно использовать мьютексы.
       

        pthread_cond_wait(&space_available, &region_mutex); //Функция pthread_cond_wait() используется, чтобы атомарно освободить мьютекс и заставить вызывающий поток блокироваться по переменной состояния. Функция pthread_cond_wait() возвращает 0 - после успешного завершения. Любое другое значение указывает, что произошла ошибка.

перед выполнением операции «ожидание» поток должен заблокировать мьютекс. При выполнении операции «ожидание» указанный мьютекс автоматически разблокируется. Перед возобновлением ожидающего потока выполняется автоматическая блокировка мьютекса, позволяющая потоку войти в критическую секцию, после критической секции рекомендуется разблокировать мьютекс. При подачи сигнала другим потокам рекомендуется так же функцию «сигнализации» защитить мьютексом.
      

  sleep(2);
      

        pthread_cond_signal(&data_available); //Вызов pthread_cond_signal () блокирует по крайней мере один из потоков, которые блокируются при указанной переменной условия cond (если какие-либо потоки заблокированы на cond ).


        pthread_mutex_unlock(&region_mutex);//разблокирует остальные потоки


    pthread_exit(NULL);


это объяснение той мути в которую я не врубаюсь
 Другими словами, если какой-то другой поток может получить мьютекс после его освобождения вызывающим потоком, то результат последующего вызова функции pthread_cond_broadcast () или pthread_cond_signal () в этом (другом) потоке будет таким, как если бы он имел место после блокирования вызывающего потока.

При успешном выполнении мьютекс будет заблокирован, а владеть им будет вызывающий поток. Функция pthread_cond_signal () используется для разблокировки по крайней мере одного из потоков, заблокированных с использованием условной переменной, заданной параметром cond (если таковые существуют).



/*Zhenya*/

pthread_cond_wait(&space_available, &region_mutex);
pthread_cond_signal(&data_available); 

Поток засыпает на условной переменной, вызвав функцию pthread_cond_wait. Поток будет оставаться в состоянии ожидания, пока какой-нибудь другой поток не просигнализирует об изменении условия (то есть изменит предикат путём добавления в очередь данных, что сделает её не пустой).

 У нас проблема: один поток удерживает блокировки и спит на условной переменной, а другой поток ожидает блокировку для установки состояния. Для того чтобы избежать такой проблемы, соответствующий мьютекс должен быть разблокирован после засыпания потока на условной переменной. Это делается в функции pthread_cond_wait. Функция помещает поток в состояние сна и автоматически освобождает мьютекс.

Поток, спящий на условной переменной, пробуждается и функция pthread_cond_wait возвращается, когда другой поток устанавливает условие (вызовом функции pthread_cond_signal.


void *producer(); Producer (изготовитель) - это некоторый поток, который генерирует “задания” и складывает их в очередь Queue.

void *consumer(); Consumer (исполнитель) - это поток, который берет задания из очереди, выполняет и отправляет результаты туда, куда нужно.

Как только поток ИЗГОТОВИТЕЛЬ добавил данные ставится а = -1 и дальше поток уходит в сон до того момента пока поток ИСПОЛНИТЕЛЬ не обработает данные и не поставит а = 1



